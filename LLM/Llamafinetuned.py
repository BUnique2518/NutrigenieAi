# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Hh0ZYfsvkcAmKa5RSVvcUHQhEkL3JHnC
"""



!pip install json5

!pip install chromadb sentence-transformers

"""
Agentic Workout Plan Enhancer with RAG (single file)

Requirements (install these before running):
    pip install requests sentence-transformers chromadb

Then run:
    python agentic_workout_pipeline.py
"""

!pip install chromadb sentence-transformers json5

import json
import textwrap
import requests
import os

import json5  # tolerant JSON parser

# =========================
# 1. CONFIG: HF & MODEL
# =========================

# Load API key from environment variable for security
HF_API_KEY = os.getenv("HF_API_KEY", "YOUR_HF_API_KEY_HERE")
MODEL_NAME = os.getenv("HF_MODEL_NAME", "meta-llama/Meta-Llama-3-8B-Instruct")

HF_CHAT_URL = "https://router.huggingface.co/v1/chat/completions"
HF_HEADERS = {
    "Authorization": f"Bearer {HF_API_KEY}",
    "Content-Type": "application/json",
}


# =========================
# 2. SAMPLE RAW WORKOUT PLAN
#    (replace with your rules-engine output)
# =========================

raw_workout_plan = {
    "profile": {
        "age": 27,
        "heightCm": 170,
        "goal": "fat_loss",
        "experience": "beginner",
        "intensity": "medium",
        "customInstructions": "knee pain, no jumping, can work out at home with dumbbells only"
    },
    "totalDurationMin": 30,
    "sections": [
        {
            "sectionType": "warmup",
            "exercises": [
                {
                    "id": "cat_cow_1",
                    "name": "Cat-Cow",
                    "primaryMuscleGroup": "spine",
                    "sets": 1,
                    "reps": 10,
                    "restSec": 30,
                    "instructions": "On all fours, alternate between arching and rounding the back."
                }
            ]
        },
        {
            "sectionType": "main",
            "exercises": [
                {
                    "id": "goblet_squat",
                    "name": "Goblet Squat",
                    "primaryMuscleGroup": "legs",
                    "sets": 3,
                    "reps": 12,
                    "restSec": 60,
                    "instructions": "Hold a dumbbell at chest, squat down and stand up."
                },
                {
                    "id": "dumbbell_row",
                    "name": "One-Arm Dumbbell Row",
                    "primaryMuscleGroup": "back",
                    "sets": 3,
                    "reps": 12,
                    "restSec": 60,
                    "instructions": "Support one hand on a bench and pull the dumbbell towards your hip."
                }
            ]
        },
        {
            "sectionType": "cooldown",
            "exercises": [
                {
                    "id": "hamstring_stretch",
                    "name": "Standing Hamstring Stretch",
                    "primaryMuscleGroup": "hamstrings",
                    "sets": 1,
                    "durationSec": 45,
                    "restSec": 15,
                    "instructions": "Place heel on low surface and lean forward to stretch back of thigh."
                }
            ]
        }
    ]
}


# =========================
# 3. KNOWLEDGE BASE (RAG) SETUP
# =========================

# Sample KB docs (inline).
# TODO: Replace these with richer, more accurate content or load from files.
KB_DOCS = [
    {
        "id": "goblet_squat_guide",
        "text": """
Goblet Squat is a lower-body strength exercise focusing on quads, glutes, and core.
Key technique:
- Hold a dumbbell or kettlebell close to your chest.
- Feet roughly shoulder-width apart, toes slightly turned out.
- Sit your hips down and back as if lowering into a chair.
- Keep chest upright and knees tracking over toes, not collapsing inward.
- Go only as low as your knees feel comfortable, especially with knee pain.

Common mistakes:
- Letting knees cave in.
- Rounding the lower back.
- Letting the heels lift off the floor.
- Rushing through the reps without control.

Variations:
- Easier: Bodyweight squat to a chair or box.
- Harder: Tempo goblet squat (3 seconds down), or heavier weight.

Breathing:
- Inhale as you lower.
- Exhale as you stand up and exert force.

Safety for knee pain:
- Reduce depth, stay in a pain-free range.
- Focus on pushing hips back and keeping shin angle moderate.
- Avoid bouncing at the bottom.
        """,
        "metadata": {"type": "exercise", "name": "Goblet Squat"}
    },
    {
        "id": "cat_cow_guide",
        "text": """
Cat-Cow is a gentle spinal mobility exercise for the back and core.
Technique:
- Start on all fours with wrists under shoulders and knees under hips.
- For Cow: Inhale, drop your belly toward the mat, lift chest and tailbone.
- For Cat: Exhale, round your spine toward the ceiling, tuck chin and tailbone.

Common mistakes:
- Rushing breath and movement.
- Letting shoulders shrug toward ears.
- Dropping into pain in the lower back.

Breathing:
- Inhale in Cow, exhale in Cat.
- Move slowly and smoothly with the breath.

Safety:
- Keep movements comfortable and controlled.
- Stop if any sharp or radiating pain appears.
        """,
        "metadata": {"type": "exercise", "name": "Cat-Cow"}
    },
    {
        "id": "knee_pain_safety",
        "text": """
General guidelines for exercising with knee pain:
- Prioritize low-impact movements (no jumping, no running).
- Limit deep knee bending if it causes pain; work in a comfortable range.
- Strengthen hips and glutes to support knee alignment.
- Focus on controlled tempo, avoid sudden changes of direction.
- Warm up thoroughly before loading the legs.
- If pain worsens during or after exercise, reduce intensity or stop and consult a professional.
        """,
        "metadata": {"type": "safety", "tag": "knee_pain"}
    },
    {
        "id": "breathing_general",
        "text": """
General breathing principles during strength training:
- Exhale on exertion (the effort phase).
- Inhale on the easier or lowering phase.
- Avoid holding your breath for long periods (no prolonged Valsalva).
- Keep breathing smooth and controlled to help manage tension and heart rate.
        """,
        "metadata": {"type": "breathing"}
    },
]

# Build vector store with chromadb + sentence-transformers
try:
    import chromadb
    from sentence_transformers import SentenceTransformer
except ImportError as e:
    raise ImportError(
        "Missing dependencies. Please install:\n"
        "  pip install chromadb sentence-transformers\n"
    ) from e

# Initialize embedding model
EMBED_MODEL_NAME = "sentence-transformers/all-mpnet-base-v2"
embed_model = SentenceTransformer(EMBED_MODEL_NAME)

# Initialize Chroma
# chroma_client = chromadb.Client()
# kb_collection = chroma_client.create_collection(name="fitness_kb")

chroma_client = chromadb.Client()
kb_collection = chroma_client.get_or_create_collection(name="fitness_kb")


def _embed_texts(texts):
    return embed_model.encode(texts).tolist()


def init_kb_collection():
    """Index KB_DOCS into the Chroma collection."""
    ids = [d["id"] for d in KB_DOCS]
    docs = [d["text"] for d in KB_DOCS]
    metas = [d["metadata"] for d in KB_DOCS]
    embeddings = _embed_texts(docs)
    kb_collection.add(ids=ids, documents=docs, metadatas=metas, embeddings=embeddings)


def retrieve_kb_snippets(query: str, top_k: int = 4):
    """Retrieve top-k relevant KB snippets given a text query."""
    query_emb = embed_model.encode([query]).tolist()[0]
    results = kb_collection.query(query_embeddings=[query_emb], n_results=top_k)
    docs = results.get("documents", [[]])[0]
    return docs  # list of strings


# =========================
# 4. BASIC LLM CALL + JSON UTILS
# =========================

# def escape_newlines_in_strings(s: str) -> str:
#     """
#     Go through the JSON-like string and replace raw newline characters that appear
#     *inside* double-quoted strings with the two-character sequence '\\n'.
#     This keeps formatting but makes it valid JSON.
#     """
#     out = []
#     in_string = False
#     escape = False

#     for ch in s:
#         if escape:
#             # After a backslash, just copy next char and reset escape flag
#             out.append(ch)
#             escape = False
#             continue

#         if ch == '\\':
#             out.append(ch)
#             escape = True
#             continue

#         if ch == '"':
#             in_string = not in_string
#             out.append(ch)
#             continue

#         # If we are inside a string and see a newline, escape it
#         if in_string and ch in ('\n', '\r'):
#             out.append('\\n')
#         else:
#             out.append(ch)

#     return ''.join(out)

def call_hf_chat(messages, max_tokens: int = 2048, temperature: float = 0.4) -> str:
    """Call Hugging Face chat API with OpenAI-style schema."""
    if HF_API_KEY == "YOUR_HF_API_KEY_HERE":
        raise ValueError("Please set HF_API_KEY at top or via environment variable.")

    payload = {
        "model": MODEL_NAME,
        "messages": messages,
        "max_tokens": max_tokens,
        "temperature": temperature,
    }

    resp = requests.post(HF_CHAT_URL, headers=HF_HEADERS, json=payload, timeout=120)
    if resp.status_code != 200:
        raise RuntimeError(f"HF API error {resp.status_code}: {resp.text}")

    data = resp.json()
    try:
        return data["choices"][0]["message"]["content"]
    except Exception as e:
        print("Unexpected HF response:", data)
        raise RuntimeError("Unexpected response format from HF chat API") from e


def extract_json(text: str) -> str:
    """
    Extract the first {...} JSON object from a string.
    Useful if the model wraps JSON with extra text.
    """
    start = text.find("{")
    end = text.rfind("}")
    if start == -1 or end == -1 or end <= start:
        raise ValueError("Could not find JSON object in the model output.")
    return text[start:end + 1]

# def safe_json_loads(json_str: str, context: str = "") -> dict:
#     """
#     Try strict json.loads first, then fall back to json5 for minor JSON issues
#     (trailing commas, single quotes, etc.). If both fail, print the content.
#     """
#     try:
#         return json.loads(json_str)
#     except json.JSONDecodeError as e1:
#         try:
#             return json5.loads(json_str)
#         except Exception as e2:
#             print("\n===== FAILED TO PARSE JSON IN CONTEXT:", context, "=====")
#             print(json_str)
#             print("===== END RAW JSON OUTPUT =====\n")
#             raise e1

# def safe_json_loads(json_str: str, context: str = "") -> dict:
#     """
#     Try strict json.loads first, then json5, then a cleanup pass where we
#     escape raw newlines inside strings and try again.
#     If everything fails, print the offending content.
#     """
#     # 1) Strict JSON
#     try:
#         return json.loads(json_str)
#     except json.JSONDecodeError as e1:
#         # 2) json5 (allows some relaxations)
#         try:
#             import json5  # make sure you did: pip install json5
#             return json5.loads(json_str)
#         except Exception:
#             # 3) Last resort: escape newlines in strings and try again
#             try:
#                 cleaned = escape_newlines_in_strings(json_str)
#                 return json.loads(cleaned)
#             except Exception as e3:
#                 print("\n===== FAILED TO PARSE JSON IN CONTEXT:", context, "=====")
#                 print(json_str)
#                 print("===== END RAW JSON OUTPUT =====\n")
#                 # Re-raise the original JSONDecodeError for traceback clarity
#                 raise e1

def escape_newlines_in_strings(s: str) -> str:
    """
    Replace raw newline characters that appear inside double-quoted strings
    with '\\n' so that JSON becomes valid.
    """
    out = []
    in_string = False
    escape = False

    for ch in s:
        if escape:
            out.append(ch)
            escape = False
            continue

        if ch == '\\':
            out.append(ch)
            escape = True
            continue

        if ch == '"':
            in_string = not in_string
            out.append(ch)
            continue

        if in_string and ch in ('\n', '\r'):
            out.append('\\n')
        else:
            out.append(ch)

    return ''.join(out)


def safe_json_loads(json_str: str, context: str = "") -> dict:
    """
    Try strict json.loads first, then json5, then escaped-newline cleanup.
    """
    try:
        return json.loads(json_str)
    except json.JSONDecodeError as e1:
        try:
            import json5
            return json5.loads(json_str)
        except Exception:
            try:
                cleaned = escape_newlines_in_strings(json_str)
                return json.loads(cleaned)
            except Exception:
                print("\n===== FAILED TO PARSE JSON IN CONTEXT:", context, "=====")
                print(json_str)
                print("===== END RAW JSON OUTPUT =====\n")
                raise e1


# =========================
# 5. AGENT 1 – PROFILE INTERPRETER
# =========================

def build_profile_summary(profile: dict) -> str:
    """
    Summarise user profile into a short text used by other agents.
    """
    system = "You are a fitness coach summarising a user's profile for downstream agents."
    user = f"""
    User profile JSON:
    {json.dumps(profile, indent=2)}

    Task:
    - Summarise key training goal, constraints, and risk factors.
    - Max 120 words.
    - Use bullet-style sentences separated by line breaks.
    - Mention equipment limits, pain areas, intensity preference, and experience.
    """

    messages = [
        {"role": "system", "content": system},
        {"role": "user", "content": user},
    ]
    summary = call_hf_chat(messages, max_tokens=256, temperature=0.2)
    return summary.strip()


# =========================
# 6. AGENT 2 – RAG-ENRICHED EXERCISE BUILDER
# =========================

# def enrich_exercise_with_rag(
#     exercise: dict,
#     profile_summary: str,
# ) -> dict:
#     """
#     Use RAG + LLM to turn one raw exercise into EnhancedExercise JSON.
#     """
#     # 1) Build retrieval query
#     query = (
#         f"Exercise: {exercise.get('name')}\n"
#         f"Primary muscle: {exercise.get('primaryMuscleGroup', '')}\n"
#         f"User constraints: {profile_summary}\n"
#     )

#     kb_snippets = retrieve_kb_snippets(query, top_k=4)
#     kb_context = "\n\n---\n\n".join(kb_snippets)

#     # 2) System prompt for strict JSON
#     system_prompt = """
#     You are a certified fitness coach and physiotherapist.

#     You receive:
#     - rawExercise: a JSON object describing one exercise in a workout plan.
#     - profileSummary: plain-text summary of user goals and constraints.
#     - kbContext: trusted reference text with technical details, safety notes and variations.

#     Your job:
#     - Enrich rawExercise into EnhancedExercise JSON.
#     - Copy numeric fields (sets, reps, durationSec, restSec) as-is.
#     - Do NOT change the exercise id or name or sets/reps.
#     - Use kbContext as the main source of factual info. If unsure, stay generic and safe.

#     Output:
#     - ONLY valid JSON, no markdown, matching this shape:

#     {
#       "id": string,
#       "name": string,
#       "primaryMuscleGroup": string,
#       "sets": number,
#       "reps": number or null,
#       "durationSec": number or null,
#       "restSec": number,
#       "instructions": string,
#       "friendlySummary": string,
#       "detailedInstructions": string,
#       "commonMistakes": string[],
#       "breathingTips": string[],
#       "easierVariation": string,
#       "harderVariation": string,
#       "safetyNotes": string
#     }
#     """

#     user_content = {
#         "rawExercise": exercise,
#         "profileSummary": profile_summary,
#         "kbContext": kb_context,
#     }

#     messages = [
#         {"role": "system", "content": textwrap.dedent(system_prompt).strip()},
#         {"role": "user", "content": json.dumps(user_content, indent=2)},
#     ]

#     # output = call_hf_chat(messages, max_tokens=1024, temperature=0.4)
#     # json_str = extract_json(output)
#     # enhanced_ex = json.loads(json_str)
#     # return enhanced_ex

#     output = call_hf_chat(messages, max_tokens=1024, temperature=0.4)
#     json_str = extract_json(output)
#     enhanced_ex = safe_json_loads(json_str, context="enrich_exercise_with_rag")
#     return enhanced_ex

def enrich_exercise_with_rag(exercise: dict, profile_summary: str) -> dict:
    """
    Use RAG + LLM as a health coach to enrich one exercise.

    Returns a dict with:
      id, name, primaryMuscleGroup, sets, reps, restSec,
      instructions, friendlySummary, detailedInstructions,
      commonMistakes, breathingTips, easierVariation,
      harderVariation, safetyNotes
    """

    # -------- 1. Build RAG context from Chroma --------
    # You already have: kb_collection (Chroma) and embedder / embedding_function
    # We'll just query by text, not raw embeddings, to keep it simple.
    query_text = (
        f"Exercise: {exercise.get('name', '')}\n"
        f"Goal/user: {profile_summary}\n"
        "Need: technique, common mistakes, breathing tips, safety and simple variations."
    )

    kb_docs = []
    try:
        rag_res = kb_collection.query(
            query_texts=[query_text],
            n_results=4,
        )
        kb_docs = rag_res.get("documents", [[]])[0] or []
    except Exception as e:
        kb_docs = []

    kb_context = "\n\n".join(kb_docs) if kb_docs else ""

    # -------- 2. Build LLM prompt (NO JSON) --------
    system_prompt = """
    You are a certified strength and conditioning coach and rehab-aware trainer.

    Your task:
    - You receive:
      - rawExercise: machine-friendly description with sets/reps/etc.
      - kbContext: relevant reference material snippets (may be empty).
      - profileSummary: high-level description of this user and their goal.

    - You must produce COACHING TEXT ONLY, with the exact markers
      specified below. DO NOT output code, DO NOT explain what you're doing.

    The enriched exercise should:
    - Keep sets/reps/rest exactly as given in rawExercise.
    - Use clear, beginner-friendly language.
    - Be conservative and safety-focused if there is pain or injury context.
    - Be generic; do not give medical diagnoses.

    STRICT OUTPUT FORMAT (no extra text outside this template):

    ID: <id>

    NAME: <name>

    PRIMARY_MUSCLE_GROUP: <muscle>

    SETS: <integer>

    REPS: <integer>

    REST_SEC: <integer>

    INSTRUCTIONS: <1–2 line plain description of the movement>

    FRIENDLY_SUMMARY:
    <2–3 sentences explaining what it does and why it's useful, in friendly tone>
    END_FRIENDLY_SUMMARY

    DETAILED_INSTRUCTIONS:
    <step-by-step technique cues, 4–8 bullets or sentences, short and clear>
    END_DETAILED_INSTRUCTIONS

    COMMON_MISTAKES:
    - <mistake 1>
    - <mistake 2>
    - <mistake 3>
    END_COMMON_MISTAKES

    BREATHING_TIPS:
    - <tip 1>
    - <tip 2>
    END_BREATHING_TIPS

    EASIER_VARIATION:
    <one simple regression, or "None" if not appropriate>

    HARDER_VARIATION:
    <one simple progression, or "None" if not appropriate>

    SAFETY_NOTES:
    <1–4 short sentences of safety notes. Mention pain, joints, form and stopping criteria.>
    END_SAFETY_NOTES
    """

    user_payload = {
        "rawExercise": exercise,
        "kbContext": kb_context,
        "profileSummary": profile_summary,
    }

    messages = [
        {"role": "system", "content": textwrap.dedent(system_prompt).strip()},
        {"role": "user", "content": json.dumps(user_payload, indent=2)},
    ]

    raw_text = call_hf_chat(messages, max_tokens=900, temperature=0.35)

    # -------- 3. Parse the tagged text into a dict --------

    def parse_block(text: str, start_tag: str, end_tag: str, join_lines: bool = True):
        """Extract text between START and END markers (first occurrence)."""
        start_idx = text.find(start_tag)
        if start_idx == -1:
            return ""
        start_idx += len(start_tag)
        end_idx = text.find(end_tag, start_idx)
        if end_idx == -1:
            block = text[start_idx:]
        else:
            block = text[start_idx:end_idx]
        lines = [l.strip() for l in block.splitlines() if l.strip()]
        if join_lines:
            return " ".join(lines)
        return lines

    def parse_list_block(text: str, start_tag: str, end_tag: str):
        """Parse list sections like:
           - item 1
           - item 2
        """
        lines = parse_block(text, start_tag, end_tag, join_lines=False)
        out = []
        for l in lines:
            if l.startswith("-"):
                item = l.lstrip("-").strip()
                if item:
                    out.append(item)
        return out

    # Simple line-based key parsing for scalar fields
    def extract_scalar(text: str, prefix: str):
        for line in text.splitlines():
            line = line.strip()
            if line.startswith(prefix):
                return line[len(prefix):].strip()
        return ""

    # Scalars
    ex_id = extract_scalar(raw_text, "ID:") or exercise.get("id", "")
    name = extract_scalar(raw_text, "NAME:") or exercise.get("name", "")
    primary = extract_scalar(raw_text, "PRIMARY_MUSCLE_GROUP:") or exercise.get("primaryMuscleGroup", "")

    def to_int_or_default(value_str: str, default: int) -> int:
        try:
            return int(value_str)
        except Exception:
            return default

    sets_str = extract_scalar(raw_text, "SETS:")
    reps_str = extract_scalar(raw_text, "REPS:")
    rest_str = extract_scalar(raw_text, "REST_SEC:")

    sets_val = to_int_or_default(sets_str, int(exercise.get("sets", 3)))
    reps_val = to_int_or_default(reps_str, int(exercise.get("reps", 10)))
    rest_val = to_int_or_default(rest_str, int(exercise.get("restSec", 60)))

    instructions_line = extract_scalar(raw_text, "INSTRUCTIONS:") or exercise.get("instructions", "")

    friendly_summary = parse_block(
        raw_text, "FRIENDLY_SUMMARY:", "END_FRIENDLY_SUMMARY"
    )

    detailed_instructions = parse_block(
        raw_text, "DETAILED_INSTRUCTIONS:", "END_DETAILED_INSTRUCTIONS"
    )

    common_mistakes = parse_list_block(
        raw_text, "COMMON_MISTAKES:", "END_COMMON_MISTAKES"
    )

    breathing_tips = parse_list_block(
        raw_text, "BREATHING_TIPS:", "END_BREATHING_TIPS"
    )

    easier_var = extract_scalar(raw_text, "EASIER_VARIATION:") or "None"
    harder_var = extract_scalar(raw_text, "HARDER_VARIATION:") or "None"

    safety_notes = parse_block(
        raw_text, "SAFETY_NOTES:", "END_SAFETY_NOTES"
    )

    # -------- 4. Build final EnhancedExercise dict --------

    enhanced_exercise = {
        "id": ex_id,
        "name": name,
        "primaryMuscleGroup": primary,
        "sets": sets_val,
        "reps": reps_val,
        "restSec": rest_val,
        "instructions": instructions_line,
        "friendlySummary": friendly_summary,
        "detailedInstructions": detailed_instructions,
        "commonMistakes": common_mistakes,
        "breathingTips": breathing_tips,
        "easierVariation": easier_var,
        "harderVariation": harder_var,
        "safetyNotes": safety_notes,
    }

    return enhanced_exercise


# =========================
# 7. AGENT 3 – PLAN COMPOSER
# =========================

# def compose_enhanced_plan(
#     raw_plan: dict,
#     enhanced_sections: list,
#     profile_summary: str,
# ) -> dict:
#     """
#     Compose final EnhancedWorkoutPlan JSON from sections with EnhancedExercise.
#     """
#     system_prompt = """
#     You are a fitness coach creating a final workout plan description.

#     You receive:
#     - rawWorkoutPlan: original plan (for duration, ordering).
#     - enhancedSections: sections with fully enriched exercises.
#     - profileSummary: summary of user goal and constraints.

#     Task:
#     - Create EnhancedWorkoutPlan JSON with:
#       - title, subtitle, overview, totalDurationMin
#       - sections: each with sectionType, title, description, exercises
#       - globalTips: 3–7 bullet-like strings
#       - disclaimer: short safety disclaimer

#     Rules:
#     - Keep sectionType and exercise ordering exactly the same.
#     - Do NOT modify exercise fields; just wrap them into sections with titles/descriptions.
#     - Respond with ONLY valid JSON, no markdown, matching:

#     {
#       "title": string,
#       "subtitle": string,
#       "overview": string,
#       "totalDurationMin": number,
#       "sections": [
#         {
#           "sectionType": "warmup" | "main" | "cooldown",
#           "title": string,
#           "description": string,
#           "exercises": [EnhancedExercise...]
#         },
#         ...
#       ],
#       "globalTips": string[],
#       "disclaimer": string
#     }
#     """

#     user_content = {
#         "rawWorkoutPlan": raw_plan,
#         "enhancedSections": enhanced_sections,
#         "profileSummary": profile_summary,
#     }

#     messages = [
#         {"role": "system", "content": textwrap.dedent(system_prompt).strip()},
#         {"role": "user", "content": json.dumps(user_content, indent=2)},
#     ]

#     # output = call_hf_chat(messages, max_tokens=1024, temperature=0.3)
#     # json_str = extract_json(output)
#     # enhanced_plan = json.loads(json_str)
#     # return enhanced_plan

#     output = call_hf_chat(messages, max_tokens=1024, temperature=0.3)
#     json_str = extract_json(output)
#     enhanced_plan = safe_json_loads(json_str, context="compose_enhanced_plan")
#     return enhanced_plan

# def compose_enhanced_plan(
#     raw_plan: dict,
#     enhanced_sections: list,
#     profile_summary: str,
# ) -> dict:
#     """
#     Ask the LLM ONLY for plan-level metadata, NOT full exercises.
#     It returns:
#       - title, subtitle, overview, globalTips, disclaimer
#       - sectionsMeta: [{ sectionType, title, description }]
#     We then merge sectionsMeta + enhanced_sections in Python.
#     """
#     system_prompt = """
#     You are a fitness coach creating a final workout plan description.

#     You receive:
#     - rawWorkoutPlan: original plan (for duration, ordering).
#     - enhancedSections: sections with fully enriched exercises (for your understanding only).
#     - profileSummary: summary of user goal and constraints.

#     Task:
#     - Create a SMALL JSON object with high-level metadata:

#     {
#       "title": string,
#       "subtitle": string,
#       "overview": string,
#       "sectionsMeta": [
#         {
#           "sectionType": "warmup" | "main" | "cooldown",
#           "title": string,
#           "description": string
#         },
#         ...
#       ],
#       "globalTips": string[],
#       "disclaimer": string
#     }

#     Rules:
#     - sectionsMeta MUST have the same sectionType values and ordering
#       as rawWorkoutPlan.sections.
#     - Do NOT include any exercise arrays in the output.
#     - Keep overview under ~200 words.
#     - Use DOUBLE QUOTES for all keys and string values.
#     - Do NOT use single quotes.
#     - Do NOT put raw line breaks inside strings; if you need line breaks,
#       use '\\n' or keep everything in a single paragraph.
#     - Do NOT include trailing commas.
#     - Respond with ONLY valid JSON, no markdown.
#     """

#     user_content = {
#         "rawWorkoutPlan": raw_plan,
#         # We include enhancedSections only to give the model context,
#         # but instruct it NOT to repeat them in the output.
#         "enhancedSections": enhanced_sections,
#         "profileSummary": profile_summary,
#     }

#     messages = [
#         {"role": "system", "content": textwrap.dedent(system_prompt).strip()},
#         {"role": "user", "content": json.dumps(user_content, indent=2)},
#     ]

#     output = call_hf_chat(messages, max_tokens=512, temperature=0.3)
#     json_str = extract_json(output)
#     meta = safe_json_loads(json_str, context="compose_enhanced_plan")

#     # Now build the final EnhancedWorkoutPlan in Python by merging
#     # sectionsMeta with enhanced_sections.
#     sections_meta = meta["sectionsMeta"]

#     merged_sections = []
#     # raw_plan["sections"] and enhanced_sections are aligned by index
#     for idx, section in enumerate(raw_plan["sections"]):
#         section_type = section["sectionType"]
#         meta_for_section = next(
#             (m for m in sections_meta if m["sectionType"] == section_type),
#             None,
#         )
#         if meta_for_section is None:
#             # fallback: simple title/description if model messed up
#             meta_for_section = {
#                 "sectionType": section_type,
#                 "title": section_type.capitalize(),
#                 "description": "",
#             }

#         merged_sections.append({
#             "sectionType": section_type,
#             "title": meta_for_section["title"],
#             "description": meta_for_section["description"],
#             "exercises": enhanced_sections[idx]["exercises"],
#         })

#     enhanced_plan = {
#         "title": meta["title"],
#         "subtitle": meta["subtitle"],
#         "overview": meta["overview"],
#         "totalDurationMin": raw_plan["totalDurationMin"],
#         "sections": merged_sections,
#         "globalTips": meta["globalTips"],
#         "disclaimer": meta["disclaimer"],
#     }

#     return enhanced_plan

# def compose_enhanced_plan(
#     raw_plan: dict,
#     enhanced_sections: list,
#     profile_summary: str,
# ) -> dict:
#     """
#     Pure-Python composer:
#     - No LLM call.
#     - Generates title, subtitle, overview, sections titles/descriptions,
#       globalTips and disclaimer from profile + plan.
#     - Uses enhanced_sections as-is for exercises.
#     """

#     profile = raw_plan.get("profile", {})
#     goal = profile.get("goal", "general_fitness")
#     intensity = profile.get("intensity", "medium")
#     experience = profile.get("experience", "beginner")
#     custom = (profile.get("customInstructions") or "").lower()
#     total_minutes = raw_plan.get("totalDurationMin", 30)

#     # --- Title ---
#     goal_title_map = {
#         "fat_loss": "Home Workout for Fat Loss",
#         "muscle_gain": "Home Workout for Muscle Gain",
#         "strength": "Strength & Conditioning Home Workout",
#         "mobility": "Mobility & Flexibility Session",
#         "general_fitness": "Full-Body Home Workout",
#     }
#     title = goal_title_map.get(goal, "Custom Home Workout Plan")

#     # --- Subtitle ---
#     intensity_phrase = {
#         "low": "Low-Intensity Routine",
#         "medium": "Medium-Intensity Routine",
#         "high": "High-Intensity Routine",
#     }.get(intensity, "Balanced-Intensity Routine")

#     knee_friendly = "knee" in custom
#     equip_phrase = ""
#     if "dumbbell" in custom or "dumbbells" in custom:
#         equip_phrase = " with Dumbbells"
#     elif "band" in custom:
#         equip_phrase = " with Resistance Bands"
#     elif "bodyweight" in custom:
#         equip_phrase = " (Bodyweight Only)"

#     subtitle_parts = [intensity_phrase]
#     if knee_friendly:
#         subtitle_parts.append("Knee-Friendly")
#     subtitle = ", ".join(subtitle_parts) + equip_phrase

#     # --- Overview ---
#     # Short, safe summary using profile info
#     goal_text = {
#         "fat_loss": "support fat loss",
#         "muscle_gain": "build muscle and strength",
#         "strength": "build strength and stability",
#         "mobility": "improve mobility and joint health",
#         "general_fitness": "improve overall fitness and energy",
#     }.get(goal, "improve your fitness")

#     overview_lines = [
#         f"This {total_minutes}-minute home workout is designed to help you {goal_text}.",
#         f"It is tailored for a {experience} level with a {intensity} intensity profile.",
#     ]

#     if knee_friendly:
#         overview_lines.append(
#             "Exercise choices and cues are selected to be knee-friendly, "
#             "with reduced impact and a focus on controlled movement."
#         )
#     if equip_phrase:
#         overview_lines.append(
#             f"The routine can be performed at home{equip_phrase.lower()}."
#         )

#     overview = " ".join(overview_lines)

#     # --- Section titles & descriptions ---
#     section_title_map = {
#         "warmup": "Warm-Up",
#         "main": "Main Workout",
#         "cooldown": "Cooldown & Stretch",
#     }
#     section_desc_map = {
#         "warmup": "Gentle movements to prepare your joints, muscles, and nervous system for exercise.",
#         "main": "Focused work on strength, control, and technique to move you towards your goal.",
#         "cooldown": "Easy stretches and breathing to help you cool down and start recovery.",
#     }

#     merged_sections = []
#     for idx, section in enumerate(raw_plan.get("sections", [])):
#         stype = section.get("sectionType", "main")
#         title_s = section_title_map.get(stype, stype.capitalize())
#         desc_s = section_desc_map.get(stype, "This section supports your overall workout.")

#         merged_sections.append({
#             "sectionType": stype,
#             "title": title_s,
#             "description": desc_s,
#             "exercises": enhanced_sections[idx]["exercises"],
#         })

#     # --- Global tips ---
#     global_tips = [
#         "Move at a pace where you can still breathe steadily and speak in short sentences.",
#         "Prioritise control and technique over speed or weight.",
#         "Stop any movement that causes sharp, pinching, or worsening pain.",
#         "Sip water regularly and avoid training on a completely empty stomach.",
#     ]
#     if knee_friendly:
#         global_tips.append(
#             "For knee comfort, stay in a pain-free range and avoid deep bending or jumping."
#         )

#     # --- Disclaimer ---
#     disclaimer = (
#         "This workout is for general educational purposes and is not a substitute for "
#         "personal medical or physiotherapy advice. If you have injuries, chronic pain, "
#         "heart, joint, or other health conditions, please consult a qualified professional "
#         "before starting or changing any exercise programme. Stop immediately if you feel "
#         "dizziness, chest pain, or unusual discomfort."
#     )

#     # --- Final plan ---
#     enhanced_plan = {
#         "title": title,
#         "subtitle": subtitle,
#         "overview": overview,
#         "totalDurationMin": total_minutes,
#         "sections": merged_sections,
#         "globalTips": global_tips,
#         "disclaimer": disclaimer,
#     }

#     return enhanced_plan

def compose_enhanced_plan(
    raw_plan: dict,
    enhanced_sections: list,
    profile_summary: str,
) -> dict:
    """
    LLM-based composer:
    - Uses the LLM as a health coach to generate plan-level copy:
      title, subtitle, overview, section titles/descriptions,
      globalTips and disclaimer.
    - Does NOT ask the LLM to regenerate exercises.
    - Uses a simple text template instead of JSON to avoid parsing issues.
    """

    # ------- 1. Build a concise prompt for the LLM -------

    profile = raw_plan.get("profile", {})
    total_minutes = raw_plan.get("totalDurationMin", 30)

    # Only send lightweight structure for sections to save tokens
    structure_preview = [
        {
            "sectionType": s.get("sectionType"),
            "numExercises": len(s.get("exercises", [])),
        }
        for s in raw_plan.get("sections", [])
    ]

    system_prompt = """
    You are a certified fitness coach and health educator.

    You will receive:
    - profileSummary: who this person is, their goal, constraints, and experience.
    - workoutStructure: list of sections (warmup, main, cooldown) with how many exercises each has.
    - totalDurationMin: approximate workout length.

    Your job:
    - Write high-level plan copy (titles, overview, tips) that is:
      - Supportive, clear, and beginner-friendly in tone.
      - Behaviourally realistic and safety-aware.
      - Short and to the point (no essay).

    IMPORTANT:
    - DO NOT invent specific exercise names or sets/reps. Those are already handled.
    - Just talk about sections in generic terms ("warm-up for your spine", "main strength block", etc.).
    - Output MUST follow the exact text format below.

    OUTPUT FORMAT (VERY IMPORTANT):
    - Use exactly these markers and order.
    - Do NOT skip any section.
    - Do NOT add extra headings.

    TITLE: <one line>

    SUBTITLE: <one line>

    OVERVIEW:
    <one or two short paragraphs>
    END_OVERVIEW

    SECTIONS_META:
    - warmup || <title for warmup> || <1–2 sentence description>
    - main || <title for main> || <1–2 sentence description>
    - cooldown || <title for cooldown> || <1–2 sentence description>

    GLOBAL_TIPS:
    - <tip 1>
    - <tip 2>
    - <tip 3>
    - <tip 4>

    DISCLAIMER:
    <2–4 sentences, concise safety disclaimer>
    """

    user_prompt = {
        "profileSummary": profile_summary,
        "workoutStructure": structure_preview,
        "totalDurationMin": total_minutes,
    }

    messages = [
        {"role": "system", "content": textwrap.dedent(system_prompt).strip()},
        {"role": "user", "content": json.dumps(user_prompt, indent=2)},
    ]

    raw_text = call_hf_chat(messages, max_tokens=600, temperature=0.45)

    # ------- 2. Parse the text template from the LLM -------

    def parse_llm_plan(text: str):
        lines = [l.rstrip() for l in text.splitlines()]

        title = ""
        subtitle = ""
        overview_lines = []
        sections_meta = []
        global_tips = []
        disclaimer_lines = []

        state = "header"  # header | overview | sections | tips | disclaimer

        for raw in lines:
            line = raw.strip()
            if not line:
                continue

            # Top-level markers
            if line.startswith("TITLE:"):
                title = line[len("TITLE:"):].strip()
                state = "header"
                continue

            if line.startswith("SUBTITLE:"):
                subtitle = line[len("SUBTITLE:"):].strip()
                state = "header"
                continue

            if line == "OVERVIEW:":
                state = "overview"
                continue

            if line == "END_OVERVIEW":
                state = "header"
                continue

            if line == "SECTIONS_META:":
                state = "sections"
                continue

            if line == "GLOBAL_TIPS:":
                state = "tips"
                continue

            if line == "DISCLAIMER:":
                state = "disclaimer"
                continue

            # Section-specific parsing
            if state == "overview":
                overview_lines.append(line)
                continue

            if state == "sections":
                # Expected: - warmup || Title || Description
                if line.startswith("-"):
                    content = line.lstrip("-").strip()
                    parts = [p.strip() for p in content.split("||")]
                    if len(parts) >= 3:
                        stype, stitle, sdesc = parts[0], parts[1], " || ".join(parts[2:])
                        sections_meta.append({
                            "sectionType": stype,
                            "title": stitle,
                            "description": sdesc,
                        })
                continue

            if state == "tips":
                if line.startswith("-"):
                    tip = line.lstrip("-").strip()
                    if tip:
                        global_tips.append(tip)
                continue

            if state == "disclaimer":
                disclaimer_lines.append(line)
                continue

        overview = " ".join(overview_lines).strip()
        disclaimer = " ".join(disclaimer_lines).strip()

        return {
            "title": title.strip(),
            "subtitle": subtitle.strip(),
            "overview": overview,
            "sectionsMeta": sections_meta,
            "globalTips": global_tips,
            "disclaimer": disclaimer,
        }

    meta = parse_llm_plan(raw_text)

    # ------- 3. Fallbacks if the model misses anything -------

    # Reuse some deterministic logic for safety
    goal = profile.get("goal", "general_fitness")
    intensity = profile.get("intensity", "medium")
    experience = profile.get("experience", "beginner")
    custom = (profile.get("customInstructions") or "").lower()

    goal_title_map = {
        "fat_loss": "Home Workout for Fat Loss",
        "muscle_gain": "Home Workout for Muscle Gain",
        "strength": "Strength & Conditioning Home Workout",
        "mobility": "Mobility & Flexibility Session",
        "general_fitness": "Full-Body Home Workout",
    }
    default_title = goal_title_map.get(goal, "Custom Home Workout Plan")

    intensity_phrase = {
        "low": "Low-Intensity Routine",
        "medium": "Medium-Intensity Routine",
        "high": "High-Intensity Routine",
    }.get(intensity, "Balanced-Intensity Routine")

    knee_friendly = "knee" in custom
    equip_phrase = ""
    if "dumbbell" in custom or "dumbbells" in custom:
        equip_phrase = " with Dumbbells"
    elif "band" in custom:
        equip_phrase = " with Resistance Bands"
    elif "bodyweight" in custom:
        equip_phrase = " (Bodyweight Only)"

    subtitle_parts = [intensity_phrase]
    if knee_friendly:
        subtitle_parts.append("Knee-Friendly")
    default_subtitle = ", ".join(subtitle_parts) + equip_phrase

    goal_text = {
        "fat_loss": "support fat loss",
        "muscle_gain": "build muscle and strength",
        "strength": "build strength and stability",
        "mobility": "improve mobility and joint health",
        "general_fitness": "improve overall fitness and energy",
    }.get(goal, "improve your fitness")

    default_overview = (
        f"This {total_minutes}-minute home workout is designed to help you {goal_text}. "
        f"It is tailored for a {experience} level with a {intensity} intensity profile."
    )

    default_global_tips = [
        "Move at a pace where you can still breathe steadily and speak in short sentences.",
        "Prioritise control and technique over speed or weight.",
        "Stop any movement that causes sharp, pinching, or worsening pain.",
        "Sip water regularly and avoid training on a completely empty stomach.",
    ]
    if knee_friendly:
        default_global_tips.append(
            "For knee comfort, stay in a pain-free range and avoid deep bending or jumping."
        )

    default_disclaimer = (
        "This workout is for general educational purposes and is not a substitute for personal "
        "medical or physiotherapy advice. If you have injuries, chronic pain, heart, joint, or "
        "other health conditions, please consult a qualified professional before starting or "
        "changing any exercise programme. Stop immediately if you feel dizziness, chest pain, "
        "or unusual discomfort."
    )

    # Apply fallbacks if needed
    title = meta["title"] or default_title
    subtitle = meta["subtitle"] or default_subtitle
    overview = meta["overview"] or default_overview
    global_tips = meta["globalTips"] or default_global_tips
    disclaimer = meta["disclaimer"] or default_disclaimer

    # Section meta fallbacks
    section_title_map = {
        "warmup": "Warm-Up",
        "main": "Main Workout",
        "cooldown": "Cooldown & Stretch",
    }
    section_desc_map = {
        "warmup": "Gentle movements to prepare your joints, muscles, and nervous system for exercise.",
        "main": "Focused work on strength, control, and technique to move you towards your goal.",
        "cooldown": "Easy stretches and breathing to help you cool down and start recovery.",
    }

    # Index sectionsMeta by sectionType for easier lookup
    meta_by_type = {m["sectionType"]: m for m in meta.get("sectionsMeta", []) if "sectionType" in m}

    merged_sections = []
    for idx, section in enumerate(raw_plan.get("sections", [])):
        stype = section.get("sectionType", "main")
        m = meta_by_type.get(stype, {})

        title_s = m.get("title") or section_title_map.get(stype, stype.capitalize())
        desc_s = m.get("description") or section_desc_map.get(
            stype, "This section supports your overall workout."
        )

        merged_sections.append({
            "sectionType": stype,
            "title": title_s,
            "description": desc_s,
            "exercises": enhanced_sections[idx]["exercises"],
        })

    # ------- 4. Build final EnhancedWorkoutPlan dict -------

    enhanced_plan = {
        "title": title,
        "subtitle": subtitle,
        "overview": overview,
        "totalDurationMin": total_minutes,
        "sections": merged_sections,
        "globalTips": global_tips,
        "disclaimer": disclaimer,
    }

    return enhanced_plan

# =========================
# 8. ORCHESTRATOR – AGENTIC PIPELINE
# =========================

def agentic_enhance_workout(raw_workout_plan: dict) -> dict:
    """
    Full pipeline:
      1) Profile summary (Agent 1)
      2) RAG-enriched exercises (Agent 2)
      3) Plan composition (Agent 3)
    """
    # Agent 1: profile summary
    profile = raw_workout_plan["profile"]
    profile_summary = build_profile_summary(profile)

    # Agent 2: enrich each exercise
    enhanced_sections = []
    for section in raw_workout_plan["sections"]:
        enriched_exercises = []
        for ex in section["exercises"]:
            enriched = enrich_exercise_with_rag(
                exercise=ex,
                profile_summary=profile_summary,
            )
            enriched_exercises.append(enriched)
        enhanced_sections.append({
            "sectionType": section["sectionType"],
            "exercises": enriched_exercises,
        })

    # Agent 3: compose final plan
    enhanced_plan = compose_enhanced_plan(
        raw_plan=raw_workout_plan,
        enhanced_sections=enhanced_sections,
        profile_summary=profile_summary,
    )

    return enhanced_plan


# =========================
# 9. MAIN (for testing)
# =========================

if __name__ == "__main__":
    # 1) Init KB
    print("Initializing knowledge base (Chroma + embeddings)...")
    init_kb_collection()

    # 2) Run pipeline
    print("Running agentic pipeline to enhance workout plan...")
    enhanced = agentic_enhance_workout(raw_workout_plan)

    # 3) Inspect a few fields
    print("\n=== PLAN TITLE ===")
    print(enhanced.get("title", ""))

    print("\n=== OVERVIEW ===")
    print(enhanced.get("overview", ""))

    print("\n=== FIRST MAIN EXERCISE ===")
    try:
        main_section = next(s for s in enhanced["sections"] if s["sectionType"] == "main")
        first_ex = main_section["exercises"][0]
        print(json.dumps(first_ex, indent=2, ensure_ascii=False))
    except Exception as e:
        print("Could not inspect first main exercise:", e)

    # Uncomment to see the full JSON:
    # print(json.dumps(enhanced, indent=2, ensure_ascii=False))

enhanced = agentic_enhance_workout(raw_workout_plan)

print(enhanced["title"])
print(enhanced["subtitle"])
print()
print(enhanced["overview"])
print()
print(json.dumps(enhanced["sections"][2]["exercises"][0], indent=2, ensure_ascii=False))













